/**
 * 将给定数字转换成二进制字符串
 * @param {number} num 给定数字
 * @returns {string} str 转换后的二进制字符串
 * @description 如果字符串长度不足 8 位，则在前面补 0 到满8位
 * @description 输入 65 输出 01000001
 * @description https://zhuanlan.zhihu.com/p/362562301
 */
function convertToBinary(num) {
  if (num > 127 || num < -128) {
    throw new Error('超出范围')
  }
  if (!Number.isInteger(num)) {
    throw new Error('请输入整数')
  }
  // 原码：按绝对值大小转换为二进制数，如果是负数，最高位补 1
  // 反码：正数的反码与原码相同；负数的反码是对该数的原码除符号位外的每一位取反
  // 补码：正数的补码和原码相同；负数的补码是对该数的原码除符号位外的每一位取反，最后一位加 1 => 负数的反码 + 最后一位加 1
  let result
  if (num >= 0) {
    result = `00000000${num.toString(2)}`.slice(-8) // 从后向前截取 8 位实现补零
  } else {
    num = Math.abs(num)
    // 上面关于负数补码的定义：
    // 非符号位部分的原码每一位取反，最后一位+1，得到负数的反码
    // 换句话说：非符号位部分，原码先-1，再每一位取反，也可以得到负数的反码 => 先在十进制内完成计算，再转二进制取反，便于操作
    // 十进制数字 -6
    // 对应的原码 1 110 （4 位二进制数表示） 1 0000110 （8 位二进制数表示）
    // 对应的反码 1 001 （4 位二进制数表示） 1 1111001 （8 位二进制数表示）
    // 对应的补码 1 010  <= 1001+1        1 1111010 （8 位二进制数表示）
    // 换个角度来说，用 5 的原码取反，符号位补 1 可得
    // 十进制数字 5
    // 对应的原码 0 101 （4 位二进制数表示） 0 00000101 （8 位二进制数表示）
    // 取反的结果 0 010 （4 位二进制数表示） 0 00000010 （8 位二进制数表示）
    // 补充符号位 1 010 （4 位二进制数表示） 1 00000010 （8 位二进制数表示）
    num = num - 1
    result = `00000000${num.toString(2)}`.slice(-8)
    result = result.split('').map(n => n == 0 ? 1 : 0).join('')
  }
  return result
}

export default convertToBinary
